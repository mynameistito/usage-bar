use crate::credentials::CredentialManager;
use crate::models::{UsageResponse, UsageData, TokenRefreshResponse, TierResponse, ClaudeTierData};
use anyhow::{anyhow, Result};
use chrono::Utc;
use reqwest::StatusCode;

const OAUTH_CLIENT_ID: &str = "9d1c250a-e61b-44d9-88ed-5944d1962f5e";
const USAGE_API_URL: &str = "https://api.anthropic.com/api/oauth/usage";
const TOKEN_REFRESH_URL: &str = "https://console.anthropic.com/v1/oauth/token";

pub struct ClaudeService;

impl ClaudeService {
  pub async fn fetch_usage() -> Result<UsageData> {
    let token = CredentialManager::read_claude_access_token()?;

    let client = reqwest::Client::builder()
      .timeout(std::time::Duration::from_secs(15))
      .build()?;

    let response = client
      .get(USAGE_API_URL)
      .header("Authorization", format!("Bearer {}", token))
      .header("anthropic-beta", "oauth-2025-04-20")
      .send()
      .await?;

    match response.status() {
      StatusCode::UNAUTHORIZED => {
        Self::refresh_token().await?;
        let token = CredentialManager::read_claude_access_token()?;
        let retry_response = client
          .get(USAGE_API_URL)
          .header("Authorization", format!("Bearer {}", token))
          .header("anthropic-beta", "oauth-2025-04-20")
          .send()
          .await?;

        Self::handle_response(retry_response).await
      }
      status if status.is_success() => {
        Self::handle_response(response).await
      }
      StatusCode::FORBIDDEN => {
        Err(anyhow!("Access denied — check your permissions"))
      }
      StatusCode::TOO_MANY_REQUESTS => {
        Err(anyhow!("Rate limited — please wait and try again"))
      }
      status if status.is_server_error() => {
        Err(anyhow!("Server error — try again later"))
      }
      _ => {
        Err(anyhow!("Failed to fetch usage data"))
      }
    }
  }

  async fn handle_response(response: reqwest::Response) -> Result<UsageData> {
    let response_text = response.text().await?;

    let usage_response: UsageResponse = serde_json::from_str(&response_text)
      .map_err(|e| anyhow!("Failed to parse usage response: {}", e))?;

    let extra_usage = usage_response.extra_usage;

    Ok(UsageData {
      five_hour_utilization: usage_response.five_hour.utilization,
      five_hour_resets_at: usage_response.five_hour.resets_at,
      seven_day_utilization: usage_response.seven_day.utilization,
      seven_day_resets_at: usage_response.seven_day.resets_at,
      extra_usage_enabled: extra_usage.as_ref().map(|e| e.is_enabled).unwrap_or(false),
      extra_usage_monthly_limit: extra_usage.as_ref().and_then(|e| e.monthly_limit),
      extra_usage_used_credits: extra_usage.as_ref().and_then(|e| e.used_credits),
      extra_usage_utilization: extra_usage.as_ref().and_then(|e| e.utilization),
    })
  }

  pub async fn refresh_token() -> Result<()> {
    let credentials = CredentialManager::read_claude_credentials()?;

    let client = reqwest::Client::builder()
      .timeout(std::time::Duration::from_secs(15))
      .build()?;

    let params = [
      ("grant_type", "refresh_token"),
      ("refresh_token", &credentials.claude_ai_oauth.refresh_token),
      ("client_id", OAUTH_CLIENT_ID),
    ];

    let response = client
      .post(TOKEN_REFRESH_URL)
      .header("Content-Type", "application/x-www-form-urlencoded")
      .form(&params)
      .send()
      .await?;

    if !response.status().is_success() {
      let error_text = response.text().await?;
      return Err(anyhow!("Token refresh failed: {}", error_text));
    }

    let refresh_response: TokenRefreshResponse = response.json().await?;

    let now = Utc::now().timestamp_millis();
    let expires_at = now + (refresh_response.expires_in * 1000);

    CredentialManager::update_claude_token(
      &refresh_response.access_token,
      &refresh_response.refresh_token,
      expires_at,
    )?;

    Ok(())
  }

  pub fn is_token_expired() -> bool {
    match CredentialManager::read_claude_credentials() {
      Ok(credentials) => {
        if let Some(expires_at) = credentials.claude_ai_oauth.expires_at {
          let now = Utc::now().timestamp_millis();
          let buffer: i64 = 60 * 1000; // 60 second buffer
          now + buffer >= expires_at
        } else {
          true
        }
      }
      Err(_) => true,
    }
  }

  pub async fn check_and_refresh_if_needed() -> Result<()> {
    if Self::is_token_expired() {
      Self::refresh_token().await?;
    }
    Ok(())
  }

  pub async fn fetch_tier() -> Result<ClaudeTierData> {
    let token = CredentialManager::read_claude_access_token()?;

    let client = reqwest::Client::builder()
      .timeout(std::time::Duration::from_secs(15))
      .build()?;

    let response = client
      .get(USAGE_API_URL)
      .header("Authorization", format!("Bearer {}", token))
      .header("anthropic-beta", "oauth-2025-04-20")
      .send()
      .await?;

    match response.status() {
      StatusCode::UNAUTHORIZED => {
        Self::refresh_token().await?;
        let token = CredentialManager::read_claude_access_token()?;
        let retry_response = client
          .get(USAGE_API_URL)
          .header("Authorization", format!("Bearer {}", token))
          .header("anthropic-beta", "oauth-2025-04-20")
          .send()
          .await?;

        Self::handle_tier_response(retry_response).await
      }
      status if status.is_success() => {
        Self::handle_tier_response(response).await
      }
      StatusCode::FORBIDDEN => {
        Err(anyhow!("Access denied — check your permissions"))
      }
      StatusCode::TOO_MANY_REQUESTS => {
        Err(anyhow!("Rate limited — please wait and try again"))
      }
      status if status.is_server_error() => {
        Err(anyhow!("Server error — try again later"))
      }
      _ => {
        Err(anyhow!("Failed to fetch tier data"))
      }
    }
  }

  async fn handle_tier_response(response: reqwest::Response) -> Result<ClaudeTierData> {
    let response_text = response.text().await?;

    let tier_response: TierResponse = serde_json::from_str(&response_text)
      .map_err(|e| anyhow!("Failed to parse tier response: {}", e))?;

    let plan_name = Self::infer_plan_name(&tier_response.rate_limit_tier, &tier_response.billing_type);
    let raw_tier = tier_response.rate_limit_tier.unwrap_or_default();

    Ok(ClaudeTierData {
      plan_name,
      rate_limit_tier: raw_tier,
    })
  }

  fn infer_plan_name(rate_limit_tier: &Option<String>, billing_type: &Option<String>) -> String {
    let tier = rate_limit_tier.as_deref().unwrap_or("").to_lowercase();
    let billing = billing_type.as_deref().unwrap_or("").to_lowercase();

    if tier.contains("max") {
      "Max".into()
    } else if tier.contains("pro") || billing.contains("stripe") {
      "Pro".into()
    } else if tier.contains("team") {
      "Team".into()
    } else if tier.contains("enterprise") {
      "Enterprise".into()
    } else {
      "Free".into()
    }
  }
}
